use crate::api::clients::LiveApiClient;
use crate::api::traits::BytebaseApi;
use crate::api::types::{Changelog, ChangelogType};
use crate::cli::ExtractArgs;
use crate::config::{ConfigOperations, ProductionConfig};
use crate::error::AppError;
use chrono::{DateTime, Utc};

pub async fn handle_extract(args: ExtractArgs) -> Result<(), AppError> {
    let config_ops = ProductionConfig;
    handle_extract_with_config(args, &config_ops).await
}

pub async fn handle_extract_with_config<C: ConfigOperations>(
    args: ExtractArgs,
    config_ops: &C,
) -> Result<(), AppError> {
    let config = config_ops.load_config().await?;
    let credentials = config.get_credentials()?;
    let mut client = LiveApiClient::new(credentials)?;

    // Ensure authentication
    client.ensure_authenticated_with_config(config_ops).await?;

    // Get environment configuration
    let env_config = config
        .environments
        .get(&args.target.env)
        .ok_or_else(|| AppError::Config(format!("Environment '{}' not found", args.target.env)))?;

    // Fetch changelogs from the API
    let changelogs = client
        .get_changelogs(&env_config.instance, &args.target.db, &env_config.project)
        .await?;

    // Filter changelogs based on criteria
    let filtered_changelogs = filter_changelogs(changelogs, args.from, args.to)?;

    // Generate and output the SQL script
    output_sql_script(&filtered_changelogs, args.from, args.to)?;

    Ok(())
}

fn filter_changelogs(
    changelogs: Vec<Changelog>,
    from_issue: Option<u32>,
    to_issue: Option<u32>,
) -> Result<Vec<Changelog>, AppError> {
    let mut filtered: Vec<Changelog> = changelogs
        .into_iter()
        .filter(|changelog| {
            // Only include MIGRATE type changelogs and those with non-empty statements
            changelog.changelog_type == Some(ChangelogType::Migrate)
                && !changelog.statement.is_empty()
        })
        .filter(|changelog| {
            // Filter by issue number range if specified
            match (from_issue, to_issue) {
                (Some(from), Some(to)) => {
                    changelog.issue.number >= from && changelog.issue.number <= to
                }
                (Some(from), None) => changelog.issue.number >= from,
                (None, Some(to)) => changelog.issue.number <= to,
                (None, None) => true,
            }
        })
        .collect();

    // Sort by creation time
    filtered.sort_by_key(|changelog| changelog.create_time);

    Ok(filtered)
}

fn output_sql_script(
    changelogs: &[Changelog],
    from_issue: Option<u32>,
    to_issue: Option<u32>,
) -> Result<(), AppError> {
    // Generate header comment
    let range_description = match (from_issue, to_issue) {
        (Some(from), Some(to)) => format!("from issue #{from} to #{to}"),
        (Some(from), None) => format!("from issue #{from} to latest"),
        (None, Some(to)) => format!("up to issue #{to}"),
        (None, None) => "all changes".to_string(),
    };

    let now = Utc::now().format("%Y-%m-%d");
    println!("-- Schema changes {range_description}");
    println!("-- Generated by shelltide on {now}");
    println!();

    // Output each changelog
    for changelog in changelogs {
        let issue_number = changelog.issue.number;
        let formatted_time = format_timestamp(changelog.create_time);

        println!("-- Issue #{issue_number}");
        println!("-- Executed: {formatted_time}");

        let safe_statement = ensure_semicolon(&changelog.statement.to_string());
        print!("{safe_statement}");
        println!();
    }

    Ok(())
}

fn format_timestamp(timestamp: DateTime<Utc>) -> String {
    timestamp.format("%Y-%m-%dT%H:%M:%SZ").to_string()
}

fn ensure_semicolon(statement: &str) -> String {
    let trimmed = statement.trim();
    if trimmed.is_empty() {
        return String::new();
    }

    if trimmed.ends_with(';') {
        format!("{trimmed}\n")
    } else {
        format!("{trimmed};\n")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ensure_semicolon() {
        assert_eq!(ensure_semicolon("SELECT 1"), "SELECT 1;\n");
        assert_eq!(ensure_semicolon("SELECT 1;"), "SELECT 1;\n");
        assert_eq!(ensure_semicolon("SELECT 1; "), "SELECT 1;\n");
        assert_eq!(ensure_semicolon("  SELECT 1  "), "SELECT 1;\n");
        assert_eq!(ensure_semicolon(""), "");
        assert_eq!(ensure_semicolon("   "), "");
    }
}
