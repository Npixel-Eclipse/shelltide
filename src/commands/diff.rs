use crate::api::clients::LiveApiClient;
use crate::api::traits::BytebaseApi;
use crate::api::types::{Changelog, ChangelogType};
use crate::cli::DiffArgs;
use crate::config::{ConfigOperations, ProductionConfig};
use crate::error::AppError;
use chrono::{DateTime, Utc};

pub async fn handle_diff(args: DiffArgs) -> Result<(), AppError> {
    let config_ops = ProductionConfig;
    handle_diff_with_config(args, &config_ops).await
}

pub async fn handle_diff_with_config<C: ConfigOperations>(
    args: DiffArgs,
    config_ops: &C,
) -> Result<(), AppError> {
    let config = config_ops.load_config().await?;
    let credentials = config.get_credentials()?;
    let mut client = LiveApiClient::new(credentials)?;

    client.ensure_authenticated_with_config(config_ops).await?;

    let env_config = config
        .environments
        .get(&args.target.env)
        .ok_or_else(|| AppError::Config(format!("Environment '{}' not found", args.target.env)))?;

    let changelogs = client
        .get_changelogs(&env_config.instance, &args.target.db)
        .await?;

    let filtered_changelogs = filter_changelogs(changelogs, args.from, args.to)?;

    if filtered_changelogs.is_empty() && args.fail_if_empty {
        eprintln!("No migration scripts found in the specified range");
        std::process::exit(2);
    }

    output_sql_script(&filtered_changelogs, args.from, args.to)?;

    Ok(())
}

fn filter_changelogs(
    changelogs: Vec<Changelog>,
    from_issue: Option<u32>,
    to_issue: Option<u32>,
) -> Result<Vec<Changelog>, AppError> {
    let mut filtered: Vec<Changelog> = changelogs
        .into_iter()
        .filter(|changelog| {
            changelog.changelog_type == Some(ChangelogType::Migrate)
                && !changelog.statement.is_empty()
                && changelog.status == "DONE"
        })
        .filter(|changelog| match (from_issue, to_issue) {
            (Some(from), Some(to)) => {
                changelog.issue.number >= from && changelog.issue.number <= to
            }
            (Some(from), None) => changelog.issue.number >= from,
            (None, Some(to)) => changelog.issue.number <= to,
            (None, None) => true,
        })
        .collect();
    filtered.sort_by_key(|changelog| changelog.create_time);

    Ok(filtered)
}

fn output_sql_script(
    changelogs: &[Changelog],
    from_issue: Option<u32>,
    to_issue: Option<u32>,
) -> Result<(), AppError> {
    let range_description = match (from_issue, to_issue) {
        (Some(from), Some(to)) => format!("from issue #{from} to #{to}"),
        (Some(from), None) => format!("from issue #{from} to latest"),
        (None, Some(to)) => format!("up to issue #{to}"),
        (None, None) => "all changes".to_string(),
    };

    let now = Utc::now().format("%Y-%m-%d");
    println!("-- Schema changes {range_description}");
    println!("-- Generated by shelltide on {now}");
    println!();

    // Output each changelog
    for changelog in changelogs {
        let issue_number = changelog.issue.number;
        let formatted_time = format_timestamp(changelog.create_time);

        println!("-- Issue #{issue_number}");
        println!("-- Executed: {formatted_time}");

        let safe_statement = ensure_semicolon(&changelog.statement.to_string());
        print!("{safe_statement}");
        println!();
    }

    Ok(())
}

fn format_timestamp(timestamp: DateTime<Utc>) -> String {
    timestamp.format("%Y-%m-%dT%H:%M:%SZ").to_string()
}

fn ensure_semicolon(statement: &str) -> String {
    let trimmed = statement.trim();
    if trimmed.is_empty() {
        return String::new();
    }

    if trimmed.ends_with(';') {
        format!("{trimmed}\n")
    } else {
        format!("{trimmed};\n")
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn test_ensure_semicolon() {
        assert_eq!(ensure_semicolon("SELECT 1"), "SELECT 1;\n");
        assert_eq!(ensure_semicolon("SELECT 1;"), "SELECT 1;\n");
        assert_eq!(ensure_semicolon("SELECT 1; "), "SELECT 1;\n");
        assert_eq!(ensure_semicolon("  SELECT 1  "), "SELECT 1;\n");
        assert_eq!(ensure_semicolon(""), "");
        assert_eq!(ensure_semicolon("   "), "");
    }
}
