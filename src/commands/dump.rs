use crate::api::clients::LiveApiClient;
use crate::api::traits::BytebaseApi;
use crate::api::types::{Changelog, ChangelogType};
use crate::cli::DumpArgs;
use crate::config::{ConfigOperations, ProductionConfig};
use crate::error::AppError;
use chrono::{DateTime, Utc};

pub async fn handle_dump(args: DumpArgs) -> Result<(), AppError> {
    let config_ops = ProductionConfig;
    handle_dump_with_config(args, &config_ops).await
}

pub async fn handle_dump_with_config<C: ConfigOperations>(
    args: DumpArgs,
    config_ops: &C,
) -> Result<(), AppError> {
    let config = config_ops.load_config().await?;
    let credentials = config.get_credentials()?;
    let mut client = LiveApiClient::new(credentials)?;

    // Ensure authentication
    client.ensure_authenticated_with_config(config_ops).await?;

    // Get environment configuration
    let env_config = config
        .environments
        .get(&args.target.env)
        .ok_or_else(|| AppError::Config(format!("Environment '{}' not found", args.target.env)))?;

    let changelogs = client
        .get_changelogs(&env_config.instance, &args.target.db)
        .await?;

    let target_changelog = find_target_changelog(changelogs, args.at_issue)?;

    match target_changelog {
        Some(changelog) => {
            output_schema_dump(&changelog, args.at_issue)?;
        }
        None => {
            if args.fail_if_empty {
                eprintln!("No suitable MIGRATE changelog found");
                if args.at_issue.is_some() {
                    eprintln!(
                        "No migrations found at or before issue #{}",
                        args.at_issue.unwrap()
                    );
                } else {
                    eprintln!("No migrations found in the database");
                }
                std::process::exit(2);
            } else {
                // Just print empty dump with header
                let issue_description = match args.at_issue {
                    Some(issue) => format!("at or before issue #{issue}"),
                    None => "at latest migration".to_string(),
                };
                let now = chrono::Utc::now().format("%Y-%m-%d");
                println!("-- Database schema dump {issue_description}");
                println!("-- No migrations found");
                println!("-- Generated by shelltide on {now}");
                println!();
            }
        }
    }

    Ok(())
}

fn find_target_changelog(
    changelogs: Vec<Changelog>,
    target_issue: Option<u32>,
) -> Result<Option<Changelog>, AppError> {
    let migrate_changelogs: Vec<Changelog> = changelogs
        .into_iter()
        .filter(|changelog| {
            changelog.changelog_type == Some(ChangelogType::Migrate)
                && !changelog.schema.is_empty()
                && changelog.status == "DONE"
        })
        .collect();

    if migrate_changelogs.is_empty() {
        return Ok(None);
    }

    match target_issue {
        Some(issue_num) => {
            let filtered: Vec<Changelog> = migrate_changelogs
                .into_iter()
                .filter(|changelog| changelog.issue.number <= issue_num)
                .collect();

            Ok(filtered.into_iter().next())
        }
        None => Ok(migrate_changelogs.into_iter().next()),
    }
}

fn output_schema_dump(changelog: &Changelog, target_issue: Option<u32>) -> Result<(), AppError> {
    let issue_description = match target_issue {
        Some(issue) => format!("at or before issue #{issue}"),
        None => "at latest migration".to_string(),
    };

    let actual_issue = changelog.issue.number;
    let formatted_time = format_timestamp(changelog.create_time);
    let now = Utc::now().format("%Y-%m-%d");

    println!("-- Database schema dump {issue_description}");
    println!("-- Actual issue: #{actual_issue}");
    println!("-- Migration executed: {formatted_time}");
    println!("-- Generated by shelltide on {now}");
    println!();
    print!("{}", changelog.schema);

    Ok(())
}

fn format_timestamp(timestamp: DateTime<Utc>) -> String {
    timestamp.format("%Y-%m-%dT%H:%M:%SZ").to_string()
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::api::types::{
        ChangeLogName, ChangedResource, Changelog, ChangelogType, IssueName, StringStatement,
    };

    fn create_test_changelog(issue_number: u32, has_schema: bool) -> Changelog {
        Changelog {
            name: ChangeLogName {
                instance: "test-instance".to_string(),
                database: "test-db".to_string(),
                number: issue_number,
            },
            create_time: Utc::now(),
            status: "DONE".to_string(),
            statement: StringStatement("SELECT 1".to_string()),
            schema: if has_schema {
                "CREATE TABLE test();".to_string()
            } else {
                "".to_string()
            },
            issue: IssueName {
                project: "test-project".to_string(),
                number: issue_number,
            },
            changed_resources: ChangedResource::default(),
            changelog_type: Some(ChangelogType::Migrate),
        }
    }

    #[test]
    fn test_find_target_changelog_with_issue() {
        let changelogs = vec![
            create_test_changelog(1000, true),
            create_test_changelog(950, true),
            create_test_changelog(900, true),
            create_test_changelog(800, false),
        ];

        let result = find_target_changelog(changelogs, Some(950)).unwrap();
        assert!(result.is_some());
        assert_eq!(result.unwrap().issue.number, 950);
    }

    #[test]
    fn test_find_target_changelog_without_issue() {
        let changelogs = vec![
            create_test_changelog(1000, true),
            create_test_changelog(950, true),
        ];

        let result = find_target_changelog(changelogs, None).unwrap();
        assert!(result.is_some());
        assert_eq!(result.unwrap().issue.number, 1000);
    }

    #[test]
    fn test_find_target_changelog_no_schema() {
        let changelogs = vec![
            create_test_changelog(1000, false),
            create_test_changelog(950, false),
        ];

        let result = find_target_changelog(changelogs, None).unwrap();
        assert!(result.is_none());
    }
}
